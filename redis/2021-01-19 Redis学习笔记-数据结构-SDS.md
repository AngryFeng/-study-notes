# 简单动态字符串SDS

`Redis`没有直接使用`C语言`传统字符串表示（以空字符串`\0`结尾的字符数组），而是使用一种名为`简单动态字符串`(simple dynamic string，SDS)的抽象类型，将**SDS**用作`Redis`的默认字符串表示。

在`Redis`中，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方。

## SDS的定义

每个`sds.h/sdshdr`结构表示一个SDS值：

```c
struct sdshdr {
    //已使用字节的数量
    unsigned int len;
    //未使用字节的数量
    unsigned int free;
    //字节数组
    char buf[];
};
```

SDS遵循C字符串以空字符`\0`结尾的惯例，不过`len`不会对该字符作计算。

> 保留空字符为结尾的好处

SDS可以直接重用C字符串函数库里面的函数，同时SDS函数自动分配额外字节空间，以及添加空字符到末尾，对SDS使用者完全透明。

## SDS与C字符串的区别

C语言使用长度位N+1的字符数组来表示长度为N的字符串，并且字符数组最后一个元素总是空字符`\0`。该方式并不能满足Redis对字符串在安全性、效率和性能上的要求。

### SDS能常数复杂度获取字符串长度

C语言的字符串不记录自身长度信息，当需要获取字符串长度时需要遍历整个字符串，时间复杂度为O(N)，而SDS能直接通过`len`属性获取到字符串长度，时间复杂度为O(1)。

同时对于字符串长度的维护工作，是有SDS的API在执行时自动完成的，使用这无须进行任何手动修改长度的操作。

### 杜绝缓冲区溢出

场景：C字符串没有记住自身长度，很容易造成缓冲区溢出。例如：在调用字符串拼接函数`char *strcat(char *dest,const char *src)`时，该函数假定用户在执行已经为`dest`分配足够多内存以容纳`src`字符串中所有内容，若假定不成立，刚好与`dest`紧挨着的内存区域中有另一字符串，此时新拼接的`src`字符串的内容就会把紧邻的C字符串覆盖，造成缓冲区溢出。

与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API需要对SDS进行修改是，API会嫌检查SDS的空间是否满足修改需求，不满足会自动扩展，再执行修改操作，避免缓冲区溢出。

### 减少修改字符串时带来的内存重分配次数

场景：C字符串直接使用字符数组存储字符串，同时不存在长度信息，当需要增长或者缩短一个C字符串，程序都必须对新字符串做一次内存重分配操作：增长时得先扩展数组避免内存溢出，缩短时得缩小数组避免内存泄露。而内存分配涉及复杂算法，可能需执行系统调用，而Redis中对字符串修改的操作很常见，大量地调用内存重分配这种耗时操作不适合。

通过`buf`数组和`free`字段，SDS实现了**空间预分配**和**惰性空间释放**两种优化策略

> 空间预分配

当SDS的API对一个SDS进行修改同时需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须空间，还会为SDS分配额外的未使用空间。额外分配未使用空间数量由公式决定：若修改后的SDS的`len`属性小于1MB，数量为`len`的值；若`len`>=1MB，数量为1MB。SDS API做字符串增长时，会先判断`free`是否满足新字符串长度要求，再决定是否做长度扩展。通过空间预分配，连续增长N次字符串，从c字符串原来的必须内存重分配N次变成了最大N次。

> 惰性空间释放

当SDS API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是修改free属性，记录下空闲的字节数量，并等待将来使用，避免缩短字符串所需的内存重分配为将来增长操作提供优化。同时提供对应APi在有需要时真正释放未使用空间。

### 二进制安全

C字符串中要求字符符合某种编码，除末尾外不可包含空字符，在使用时，不能保存二进制数据。而SDS API以处理二进制的方式处理SDS存放在`buf`数组中的数据，同时使用`len`属性记录字符串结束。 

### 兼容部分C字符串函数







